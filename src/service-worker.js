import { files, shell } from '@sapper/service-worker';
import { version } from './client/TS.mjs';
import { extraURLS } from './client/URL2cache.mjs';

// See https://sapper.svelte.dev/docs#Deploying_service_workers
function getTimeStamp () {
    try {
        return version;
    } catch (exc) {
        return process.env.SAPPER_TIMESTAMP;
    }
}
const timestamp = getTimeStamp();

const ASSETS = `cache${timestamp}`;

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = shell.concat(files);
const staticAssets = new Set(to_cache);

self.addEventListener('install', event => {
    console.log(`SW: installing ...`); // DEBUG
	event.waitUntil(
		caches
			.open(ASSETS)
            .then(cache => cache.addAll(to_cache))
			.then(() => {
                console.log(`SW: cache filled`); // DEBUG
				self.skipWaiting();
                console.log(`SW: skip waited`); // DEBUG
                /* no await */ cacheExtraURLS(extraURLS);
			})
	);
});

function cacheExtraURLS (extraURLS) {
    return Promise.allSettled(
        extraURLS.map(url => fetchAndCache(url)) );
}

self.addEventListener('activate', event => {
	event.waitUntil(
		caches.keys().then(async keys => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) await caches.delete(key);
			}

			self.clients.claim();
		})
	);
});


/**
 * Fetch the asset from the network and store it in the cache. 
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request) {
	const cache = await caches.open(`offline${timestamp}`)

	try {
		const response = await fetch(request);
		cache.put(request, response.clone());
		return response;
	} catch (err) {
		const response = await cache.match(request);
		if (response) return response;

		throw err;
	}
}

function isCodeGradXRequest (url) {
    // We already know that it is an https? GET request:
    if ( url.hostname.match(/^[xes]\d*[.]codegradx[.]org/ ) ) {
        return true;
    }
    return false;
}

function shouldCacheCodeGradXRequest (url) {
    if ( url.hostname.match(/^x\d*[.]/ ) ) {
        if ( url.pathname.match(/^\/exercisesset\/path\//) ) {
            return true;
        }
        if ( url.pathname.match(/^\/fromp\/getua/) &&
             url.search.match(/lang=fr/) ) {
            return true;
        }
    }
    if ( url.hostname.match(/^e\d*[.]/ ) ) {
        if ( url.pathname.match(/^\/exercisecontent\/U.{80,}\/content/) ) {
            return true;
        }
    }
    if ( url.hostname.match(/^s\d*[.]/ ) ) {
        if ( url.pathname.match(/\/^s\/.*[.]xml/) ) {
            return true;
        }
    }
    return false;
}

self.addEventListener('fetch', event => {
	if (event.request.method !== 'GET' ||
        event.request.headers.has('range')) return;

	const url = new URL(event.request.url);

	// don't try to handle e.g. data: URIs
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest = url.hostname === self.location.hostname &&
          url.port !== self.location.port;
	const isStaticAsset = url.host === self.location.host &&
          staticAssets.has(url.pathname);
	const skipBecauseUncached = event.request.cache === 'only-if-cached' &&
          !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
		event.respondWith(
			(async () => {
				// always serve static files and bundler-generated
				// assets from cache.
                if ( isStaticAsset ) {
				    const cachedAsset = await caches.match(event.request);
                    return cachedAsset || fetchAndCache(event.request);
                }

                if ( isCodeGradXRequest(url) ) {
                    console.log(`ConstellationCache? ${url.href}`); //DEBUG
                    if ( shouldCacheCodeGradXRequest(url) ) {
                        console.log(`ConstellationCacheYes! ${url.href}`); //DEBUG
                        const cachedResponse =
                              await caches.match(event.request);
                        if ( cachedResponse ) {
                            console.log(`ConstellationCacheUsed ${url.href}`); //DEBUG
                        }
                        return cachedResponse || fetchAndCache(event.request);
                    } else {
                        return fetch(event.request);
                    }
                }

				return fetchAndCache(event.request);
			})()
		);
	}
});
